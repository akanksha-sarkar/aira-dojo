#!/bin/bash
#
# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

# if it's one-gpu machine, let's maybe nvidia-smi to see if it's busy
# to stderr
nvidia-smi >&2

df -hT >&2
hostname -f >&2
hostname -I >&2
apptainer instance list -a -j >&2

set -e

if [[ -z "$TMP_BASE_DIR" ]]; then
    TMP_BASE_DIR="/scratch/$SLURM_JOBID/"
fi
mkdir -p $TMP_BASE_DIR

# for some crazy reason, slurm doesn't set/enforce max memory size
# and doesn't kill the processes exceeding it
# so we need to do it ourselves

# set MEMORY_LIMIT_IN_MB first from SLURM_MEM_PER_TASK and SLURM_MEM_PER_NODE if first is not set
MEMORY_LIMIT_IN_MB=$SLURM_MEM_PER_TASK
if [[ -z "$SLURM_MEM_PER_TASK" ]]; then
    MEMORY_LIMIT_IN_MB=$SLURM_MEM_PER_NODE
fi

# given $SLURM_MEM_PER_NODE # in MB
MEMORY_LIMIT_IN_BYTES=$((MEMORY_LIMIT_IN_MB * 1024))
ulimit -v 100000000 # 100GBs

# First, we make unique identifier and the temporary overlay image
echo "Making tmp directory" >&2
TMP_DIR=$(mktemp -d -p $TMP_BASE_DIR sandbox-XXXXXXXXXX)
echo "Created temporary dir $TMP_DIR. As it's in /tmp, slurm will handle the cleanup properly" >&2
INSTANCE_NAME=$(basename "$TMP_DIR")


# This is for Jupyter Kernel Gateway to know the hostname / ip exposed
KG_IP=$(hostname -i)

echo "Hostname: $(hostname -f)" >&2

# to stop apptainer instance on termination
# apptainer will handle proper cleanup of all the resources other than the overlay
# then we remove the overlay image
cleanup() {
    local trigger="$1"            # e.g., SIGINT, SIGTERM, or EXIT

    echo "Stopping instance..." >&2
    apptainer instance stop "$INSTANCE_NAME"
    echo "Cleaning up..." >&2
    if [[ -n "$TMP_DIR" && -d "$TMP_DIR" ]]; then
        rm -rf "$TMP_DIR"
        echo "Removed temporary directory $TMP_DIR" >&2
    fi
    exit 0
}

trap 'cleanup SIGINT'  SIGINT
trap 'cleanup SIGTERM' SIGTERM
trap 'cleanup EXIT'    EXIT


echo "Creating overlay" >&2
if [[ "$IMAGE_OVERLAY" == "1" ]]; then
OVERLAY_PATH="$TMP_DIR/overlay.sparse.img"
apptainer overlay create --fakeroot --sparse --size 1048576 "$OVERLAY_PATH"
else
    OVERLAY_PATH="$TMP_DIR"
fi

# set SUPERIMAGE_VERSION to default if not set
if [ -z "$SUPERIMAGE_VERSION" ]; then
    SUPERIMAGE_VERSION=2025-10-07
fi

# if not BASE_OVERLAYS is set, set it to empty
if [ -z "$BASE_OVERLAYS" ]; then
    BASE_OVERLAYS=""
fi


cache_to_tmp() {
    echo "Patching APPTAINER_BIND" >&2
    BASE="/shared/cache/dojo/tasks/sciduc"
    echo "Original: $APPTAINER_BIND" >&2
    # Grab the first bind entry that starts with BASE/
    ORIG=$(echo $APPTAINER_BIND | grep -Eo "(^|,)/.*?/shared/cache/dojo/tasks/sciduc/.*?/prepared/public" || true)
    echo "Original path: $ORIG" >&2
    [ -z "$ORIG" ] && return 0     # Nothing to patchâ€”exit silently
    echo "Original path: $ORIG" >&2
    TASKNAME=$(basename $(realpath "$ORIG/../..")) # Get the task name
    echo "TASKNAME: $TASKNAME" >&2

    NEW="$TMP_BASE_DIR/${ORIG}"              # Mirror path under /tmp
    DONE_MARKER="$NEW/.completed"

    
    # Rewrite every occurrence in APPTAINER_BIND
    APPTAINER_BIND="${APPTAINER_BIND//$ORIG/$NEW}"
    export APPTAINER_BIND
    echo "Rewrote APPTAINER_BIND to $APPTAINER_BIND" >&2



    # First call only: make dir, copy once, plant the flag
    if [ ! -f "$DONE_MARKER" ]; then
        TARBALL_PATH=$(realpath "$ORIG/../public.tar")
        # now check if the tarball exists then extract it to the new location
        # otherwise copy the original

        if [ -f "$TARBALL_PATH" ]; then
            echo "Extracting $TARBALL_PATH to $NEW" >&2
            mkdir -p "$NEW"
            # Extract the tarball to the new location
            tar -xf "$TARBALL_PATH" -C "$NEW/.."
            touch "$DONE_MARKER"
        else
            echo "Tarball not found, copying directory" >&2
            if [ -n "$ORIG" ]; then
                echo "Copying $ORIG to $NEW" >&2
                mkdir -p "$NEW"
                # Plain old copy, preserving attrs (-a). Trailing dots keep cp happy.
                cp -a "$ORIG"/. "$NEW"/
            fi
            : > "$DONE_MARKER"
        fi

    fi
}

# cache_to_tmp
APPTAINER_BIND=$(echo "$APPTAINER_BIND" | sed 's#:/root/data:ro#:/data:ro#g')
# Add DNS resolution for network connectivity
APPTAINER_BIND="${APPTAINER_BIND},/etc/resolv.conf:/etc/resolv.conf:ro"
export APPTAINER_BIND

APPTAINER_BIND=$(echo "$APPTAINER_BIND" | sed 's#:/root/data:ro#:/data:ro#g')
# Add DNS resolution for network connectivity
APPTAINER_BIND="${APPTAINER_BIND},/etc/resolv.conf:/etc/resolv.conf:ro"
export APPTAINER_BIND

# --- DEBUG: Verify that the bind paths exist and point to the correct dataset ---
echo "[DEBUG] Current APPTAINER_BIND: $APPTAINER_BIND" >&2
HOST_PATH=$(echo "$APPTAINER_BIND" | cut -d':' -f1)
echo "[DEBUG] Checking real host path: $HOST_PATH" >&2
if [ -d "$HOST_PATH" ]; then
    echo "[DEBUG] Host path exists. Realpath: $(realpath "$HOST_PATH")" >&2
    echo "[DEBUG] Filesystem info:" >&2
    df -hT "$HOST_PATH" >&2 | head -n 2
    echo "[DEBUG] First few entries:" >&2
    ls -lh "$HOST_PATH" | head >&2
else
    echo "[WARN] Host path $HOST_PATH does NOT exist or is not accessible!" >&2
fi
# -------------------------------------------------------------------------------

if [ ! -f $TMP_BASE_DIR/superimage.root.$SUPERIMAGE_VERSION.sif ]; then
    echo "Copying image.sif from superimage to /tmp/progress.sif" >&2
    cp ${SUPERIMAGE_DIR}superimage.root.$SUPERIMAGE_VERSION.sif $TMP_BASE_DIR/progress.superimage.root.$SUPERIMAGE_VERSION.sif
    # to make sure it's not half-copied
    mv $TMP_BASE_DIR/progress.superimage.root.$SUPERIMAGE_VERSION.sif $TMP_BASE_DIR/superimage.root.$SUPERIMAGE_VERSION.sif
fi


if [[ -z "$HF_CACHE_HOST" ]]; then
  if [[ -d /shared && -w /shared ]]; then
    HF_CACHE_HOST="/shared/hf-cache"
  else
    HF_CACHE_HOST="$TMP_BASE_DIR/hf-cache" 
  fi
fi
mkdir -p "$HF_CACHE_HOST/hub" "$HF_CACHE_HOST/transformers"

if [[ -z "$APPTAINER_BIND" ]]; then
  APPTAINER_BIND="$HF_CACHE_HOST:/cache:rw"
else
  APPTAINER_BIND="$APPTAINER_BIND,$HF_CACHE_HOST:/cache:rw"
fi
export APPTAINER_BIND

if [[ "$NO_PROXY" == *"huggingface.co"* ]] || [[ "$no_proxy" == *"huggingface.co"* ]]; then
  echo "[WARN] NO_PROXY contains huggingface.co, which may cause issues with Hugging Face Hub" >&2
fi
# ---------------------------------------------------------------------------
echo "HF_CACHE_HOST = $HF_CACHE_HOST"

apptainer instance run \
    --containall \
    --cleanenv \
    --no-home \
    --writable-tmpfs \
    --env SSH_PUBLIC_KEY="$SSH_PUBLIC_KEY" \
    --env KG_IP="$KG_IP" \
    --env PYTHONUNBUFFERED=1 \
    --env WANDB_DISABLED=1 \
    --env TQDM_DISABLE=1 \
    --env HTTP_PROXY=$RAD_HTTP_PROXY \
    --env HTTPS_PROXY=$RAD_HTTPS_PROXY \
    --env NO_PROXY=$RAD_NO_PROXY \
    --env HF_TOKEN=$RAD_HF_TOKEN \
    --env HF_HUB_VERBOSITY=$RAD_HF_HUB_VERBOSITY \
    --env HF_HUB_OFFLINE=0 \
    --env TRANSFORMERS_OFFLINE=0 \
    --env HF_HUB_DISABLE_PROGRESS_BARS=1 \
    --env HF_HUB_DISABLE_TELEMETRY=1 \
    --env CUDA_LAUNCH_BLOCKING=1 \
    --env NLTK_DATA=$RAD_NLTK_DATA \
    --env TF_CPP_MIN_LOG_LEVEL=3 \
    --env TORCH_HOME=/cache/torch \
    --env XDG_CACHE_HOME=/cache/xdg \
    --env JUPYTER_RUNTIME_DIR=/tmp/jupyter_runtime \
    --env HOME=/tmp \
    --env HF_HOME=/cache/hub \
    --env TRANSFORMERS_CACHE=/cache/transformers \
    --nv \
    $TMP_BASE_DIR/superimage.root.$SUPERIMAGE_VERSION.sif \
    "$INSTANCE_NAME" \
    $@

echo "[DEBUG] Listing files in ~/.cache:"
ls -lah ~/.cache > output.txt

echo "[DEBUG] Inspecting container filesystem layout..." >&2
apptainer exec instance://$INSTANCE_NAME bash -c '
    echo "[DEBUG - inside container] Current working directory:" && pwd
    echo "[DEBUG - inside container] Top-level directories:" && ls -lh /
    echo "[DEBUG - inside container] /data directory contents (if present):" && ls -lh /data || echo "No /data directory"
    echo "[DEBUG - inside container] ./data directory contents (relative):" && ls -lh ./data || echo "No ./data directory"
    echo "[DEBUG - inside container] Present working directory structure:" && ls -lh | head -n 20
' >&2

echo "[DEBUG] Checking dataset files and symlink integrity..." >&2
apptainer exec instance://$INSTANCE_NAME bash -c '
    echo "[DEBUG - inside container] train/images directory status:" && \
    if [ -d "/data/train/images" ]; then
        echo "[DEBUG] Found /data/train/images, listing 10 entries:" && \
        ls -lh /data/train/images | head -n 10 && \
        echo "[DEBUG] Counting total files and broken symlinks:" && \
        echo "Total files:" $(find /data/train/images -type f | wc -l) && \
        echo "Total symlinks:" $(find /data/train/images -type l | wc -l) && \
        echo "Broken symlinks:" $(find /data/train/images -xtype l | wc -l) && \
        echo "Example broken symlinks (if any):" && \
        find /data/train/images -xtype l | head -n 10 || echo "[DEBUG] No broken symlinks detected."
    else
        echo "[ERROR] /data/train/images not found!"
    fi
' >&2
echo "After starting"

# to pipe the output of the instance
tail -f "$HOME/.apptainer/instances/logs/$(hostname)/$USER/$INSTANCE_NAME.err" >&2
